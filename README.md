# üìò H∆∞·ªõng D·∫´n S·ª≠ D·ª•ng Th∆∞ Vi·ªán Multi-Button

## üéØ Gi·ªõi Thi·ªáu
Th∆∞ vi·ªán Multi-Button l√† m·ªôt th∆∞ vi·ªán x·ª≠ l√Ω n√∫t nh·∫•n ƒëa nƒÉng, h·ªó tr·ª£ nhi·ªÅu lo·∫°i s·ª± ki·ªán v√† d·ªÖ d√†ng port cho nhi·ªÅu lo·∫°i MCU kh√°c nhau.

## üì¶ C√†i ƒê·∫∑t

### 1. Th√™m Files V√†o Project
```
project/
‚îú‚îÄ‚îÄ main.c
‚îú‚îÄ‚îÄ multi_button.h
‚îú‚îÄ‚îÄ multi_button.c
‚îî‚îÄ‚îÄ Makefile
```

### 2. C·∫•u H√¨nh Platform
Trong file `main.c`, ƒë·ªãnh nghƒ©a c√°c macro platform:

```c
// ƒê·ªãnh nghƒ©a h√†m l·∫•y th·ªùi gian (milliseconds)
uint32_t platform_get_time_ms(void) {
    // STM32: return HAL_GetTick();
    // ESP32: return xTaskGetTickCount() * portTICK_PERIOD_MS;
    // AVR: return millis(); // N·∫øu d√πng Arduino framework
    return your_timer_function();
}

// ƒê·ªãnh nghƒ©a h√†m delay
void platform_delay_ms(uint32_t ms) {
    // STM32: HAL_Delay(ms);
    // ESP32: vTaskDelay(ms / portTICK_PERIOD_MS);
    // Non-blocking delay implementation
}

#define BUTTON_GET_TIME() platform_get_time_ms()
#define BUTTON_DELAY_MS(ms) platform_delay_ms(ms)

#include "multi_button.h"
```

## üöÄ Quick Start

### 1. Kh·ªüi T·∫°o N√∫t Nh·∫•n C∆° B·∫£n
```c
#include "multi_button.h"

// H√†m ƒë·ªçc tr·∫°ng th√°i ch√¢n
bool read_button_pin(void* context) {
    uint8_t pin = (uint8_t)(uintptr_t)context;
    // return HAL_GPIO_ReadPin(GPIOA, pin) == GPIO_PIN_SET; // STM32
    // return gpio_get_level(pin); // ESP32
    return your_read_pin_function(pin);
}

// Callback x·ª≠ l√Ω s·ª± ki·ªán
void button_event_handler(button_handle_t* button, button_event_t event) {
    int button_id = (int)button->user_data;
    
    switch (event) {
        case BUTTON_EVENT_PRESSED:
            printf("Button %d pressed\n", button_id);
            break;
        case BUTTON_EVENT_CLICK:
            printf("Button %d clicked\n", button_id);
            break;
        // Th√™m c√°c event kh√°c...
    }
}

int main() {
    button_handle_t my_button;
    
    // Kh·ªüi t·∫°o v·ªõi config m·∫∑c ƒë·ªãnh
    button_init(&my_button, read_button_pin, (void*)1, NULL);
    button_set_user_data(&my_button, (void*)1);
    
    // G·∫Øn callback
    button_attach_event(&my_button, BUTTON_EVENT_CLICK, button_event_handler);
    button_attach_event(&my_button, BUTTON_EVENT_PRESSED, button_event_handler);
    
    while (1) {
        button_update(&my_button);
        BUTTON_DELAY_MS(10);
    }
}
```

## ‚öôÔ∏è C·∫•u H√¨nh

### Config M·∫∑c ƒê·ªãnh
```c
button_config_t config_default = {
    .debounce_time_ms = 25,         // Th·ªùi gian ch·ªëng rung
    .click_time_ms = 400,           // Th·ªùi gian x√°c ƒë·ªãnh click
    .long_press_time_ms = 1000,     // Th·ªùi gian long press
    .ultra_long_press_time_ms = 3000, // Th·ªùi gian ultra long press
    .multi_click_interval_ms = 300, // Kho·∫£ng c√°ch gi·ªØa c√°c click
    .sequence_timeout_ms = 2000,    // Timeout cho sequence
    .multi_click_count = 3,         // S·ªë click cho multi-click
    .active_low = true,             // Ch·∫ø ƒë·ªô active low (pull-up)
    .enable_advanced_events = false // B·∫≠t event n√¢ng cao
};
```

### Custom Config
```c
button_config_t custom_config = {
    .debounce_time_ms = 30,
    .click_time_ms = 500,
    .long_press_time_ms = 1500,
    .ultra_long_press_time_ms = 5000,
    .multi_click_interval_ms = 400,
    .multi_click_count = 4,
    .active_low = true,
    .enable_advanced_events = true
};

button_init(&button, read_pin_func, context, &custom_config);
```

## üé™ C√°c Lo·∫°i S·ª± Ki·ªán

### Basic Events
```c
BUTTON_EVENT_PRESSED          // Nh·∫•n xu·ªëng
BUTTON_EVENT_RELEASED         // Nh·∫£ ra
BUTTON_EVENT_CLICK            // Click ƒë∆°n
BUTTON_EVENT_DOUBLE_CLICK     // Double click
BUTTON_EVENT_TRIPLE_CLICK     // Triple click
```

### Long Press Events
```c
BUTTON_EVENT_LONG_PRESS_START   // B·∫Øt ƒë·∫ßu long press
BUTTON_EVENT_LONG_PRESS_HOLD    // Gi·ªØ long press (g·ªçi li√™n t·ª•c)
BUTTON_EVENT_LONG_PRESS_END     // K·∫øt th√∫c long press

BUTTON_EVENT_ULTRA_LONG_PRESS_START  // Ultra long press (>3s)
BUTTON_EVENT_ULTRA_LONG_PRESS_HOLD
BUTTON_EVENT_ULTRA_LONG_PRESS_END
```

### Advanced Events
```c
BUTTON_EVENT_SEQUENCE_START      // B·∫Øt ƒë·∫ßu chu·ªói click
BUTTON_EVENT_SEQUENCE_COMPLETE   // Ho√†n th√†nh chu·ªói
BUTTON_EVENT_COMBO_START         // Combo nhi·ªÅu n√∫t
BUTTON_EVENT_COMBO_COMPLETE      // Ho√†n th√†nh combo

// Custom events cho m·ªü r·ªông
BUTTON_EVENT_CUSTOM_1
BUTTON_EVENT_CUSTOM_2
BUTTON_EVENT_CUSTOM_3
```

## üìã API Reference

### Initialization
```c
void button_init(button_handle_t* button, 
                button_read_pin_t read_func, 
                void* context, 
                const button_config_t* config);
```

### Event Management
```c
// G·∫Øn callback cho t·ª´ng event
void button_attach_event(button_handle_t* button, 
                        button_event_t event, 
                        button_event_callback_t callback);

// G·ª° callback
void button_detach_event(button_handle_t* button, button_event_t event);

// G·∫Øn callback cho t·∫•t c·∫£ events
void button_attach_all_events(button_handle_t* button, 
                             button_event_callback_t callback);

// K√≠ch ho·∫°t event th·ªß c√¥ng
void button_trigger_event(button_handle_t* button, button_event_t event);
```

### Button Processing
```c
// C·∫≠p nh·∫≠t tr·∫°ng th√°i n√∫t
void button_update(button_handle_t* button);

// C·∫≠p nh·∫≠t nhi·ªÅu n√∫t c√πng l√∫c
void button_update_all(button_handle_t* buttons[], uint8_t count);
```

### Utility Functions
```c
// L·∫•y th√¥ng tin
uint32_t button_get_press_duration(const button_handle_t* button);
uint8_t button_get_click_count(const button_handle_t* button);
bool button_is_pressed(const button_handle_t* button);
bool button_is_long_pressed(const button_handle_t* button);

// Qu·∫£n l√Ω user data
void button_set_user_data(button_handle_t* button, void* user_data);
void* button_get_user_data(const button_handle_t* button);
```

## üéØ V√≠ D·ª• S·ª≠ D·ª•ng

### 1. X·ª≠ L√Ω Multiple Buttons
```c
button_handle_t btn1, btn2, btn3;

void setup_buttons() {
    button_init(&btn1, read_pin, (void*)1, NULL);
    button_init(&btn2, read_pin, (void*)2, NULL);
    button_init(&btn3, read_pin, (void*)3, NULL);
    
    button_set_user_data(&btn1, (void*)1);
    button_set_user_data(&btn2, (void*)2);
    button_set_user_data(&btn3, (void*)3);
    
    // G·∫Øn callback
    button_attach_event(&btn1, BUTTON_EVENT_CLICK, btn_click_handler);
    button_attach_event(&btn2, BUTTON_EVENT_LONG_PRESS_START, btn_longpress_handler);
}

void main_loop() {
    button_handle_t* buttons[] = {&btn1, &btn2, &btn3};
    button_update_all(buttons, 3);
    BUTTON_DELAY_MS(10);
}
```

### 2. Advanced Event Handling
```c
void advanced_event_handler(button_handle_t* button, button_event_t event) {
    switch (event) {
        case BUTTON_EVENT_CLICK:
            handle_single_click(button);
            break;
        case BUTTON_EVENT_DOUBLE_CLICK:
            handle_double_click(button);
            break;
        case BUTTON_EVENT_LONG_PRESS_START:
            start_long_press_action(button);
            break;
        case BUTTON_EVENT_ULTRA_LONG_PRESS_START:
            emergency_shutdown(button);
            break;
        case BUTTON_EVENT_SEQUENCE_COMPLETE:
            if (button_get_click_count(button) == 5) {
                enable_admin_mode();
            }
            break;
    }
}
```

### 3. Custom Callback v·ªõi User Data
```c
void custom_callback(button_handle_t* button, void* data) {
    printf("Custom action with data: %s\n", (char*)data);
}

// Setup
button_set_custom_callback(&my_button, custom_callback, "SecretData");
```

## üîß Porting Guide

### 1. ƒê·ªãnh Nghƒ©a Platform Functions
```c
// STM32 Example
uint32_t platform_get_time_ms(void) {
    return HAL_GetTick();
}

void platform_delay_ms(uint32_t ms) {
    HAL_Delay(ms);
}

// ESP32 Example
uint32_t platform_get_time_ms(void) {
    return xTaskGetTickCount() * portTICK_PERIOD_MS;
}

void platform_delay_ms(uint32_t ms) {
    vTaskDelay(ms / portTICK_PERIOD_MS);
}
```

### 2. Implement Pin Read Function
```c
// STM32
bool read_pin_stm32(void* context) {
    uint16_t pin = (uint16_t)(uintptr_t)context;
    return HAL_GPIO_ReadPin(GPIOA, pin) == GPIO_PIN_SET;
}

// ESP32
bool read_pin_esp32(void* context) {
    int pin = (int)context;
    return gpio_get_level(pin);
}

// Generic MCU
bool read_pin_generic(void* context) {
    volatile uint32_t* port = (volatile uint32_t*)context;
    return (*port & 0x01) != 0;
}
```

## üêõ Debugging

### Enable Debug Output
```c
void button_event_handler(button_handle_t* button, button_event_t event) {
    const char* event_names[] = {
        "PRESSED", "RELEASED", "CLICK", "DOUBLE_CLICK", "TRIPLE_CLICK",
        "LONG_PRESS_START", "LONG_PRESS_HOLD", "LONG_PRESS_END",
        "ULTRA_LONG_START", "ULTRA_LONG_HOLD", "ULTRA_LONG_END",
        "SEQUENCE_START", "SEQUENCE_COMPLETE", "COMBO_START", "COMBO_COMPLETE",
        "CUSTOM_1", "CUSTOM_2", "CUSTOM_3", "NONE"
    };
    
    printf("Button %d: %s\n", (int)button->user_data, event_names[event]);
    
    // Debug th√¥ng tin th√™m
    if (event == BUTTON_EVENT_LONG_PRESS_HOLD) {
        printf("Press duration: %lums\n", button_get_press_duration(button));
    }
}
```

## üìù Best Practices

### 1. Timing Configuration
```c
// Cho button v·∫≠t l√Ω th√¥ng th∆∞·ªùng
config.debounce_time_ms = 20-50ms
config.click_time_ms = 300-500ms
config.long_press_time_ms = 800-1200ms

// Cho touch button
config.debounce_time_ms = 50-100ms
config.click_time_ms = 200-400ms
```

### 2. Memory Management
```c
// S·ª≠ d·ª•ng static allocation cho embedded systems
static button_handle_t buttons[MAX_BUTTONS];

// Ho·∫∑c dynamic allocation n·∫øu MCU h·ªó tr·ª£
button_handle_t* buttons = malloc(sizeof(button_handle_t) * num_buttons);
```

### 3. Performance Optimization
```c
// S·ª≠ d·ª•ng button_update_all() cho nhi·ªÅu n√∫t
button_handle_t* button_list[] = {&btn1, &btn2, &btn3, &btn4};
button_update_all(button_list, 4);

// Tr√°nh blocking delay trong callbacks
void button_handler(button_handle_t* button, button_event_t event) {
    // T·ªët: Set flags v√† x·ª≠ l√Ω sau
    if (event == BUTTON_EVENT_CLICK) {
        button_click_flag = true;
    }
    
    // Kh√¥ng t·ªët: Blocking operations
    // HAL_Delay(1000); // ‚ùå Tr√°nh l√†m ƒëi·ªÅu n√†y
}
```

## üé® Extension Examples

### Combo Detection Extension
```c
#include "multi_button.h"

typedef struct {
    button_handle_t** buttons;
    uint8_t count;
    uint32_t timeout;
} button_combo_t;

void check_combo(button_combo_t* combo) {
    uint8_t pressed = 0;
    for (uint8_t i = 0; i < combo->count; i++) {
        if (button_is_pressed(combo->buttons[i])) {
            pressed++;
        }
    }
    
    if (pressed == combo->count) {
        printf("Combo activated!\n");
    }
}
```

## üìä Event Flow Diagram
```
Raw Input ‚Üí Debounce ‚Üí State Machine ‚Üí Event Detection ‚Üí Callback Execution
    ‚îÇ          ‚îÇ            ‚îÇ               ‚îÇ                  ‚îÇ
    ‚îÇ          ‚îÇ            ‚îú‚Üí Pressed ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚Üí BUTTON_EVENT_PRESSED
    ‚îÇ          ‚îÇ            ‚îú‚Üí Released ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚Üí BUTTON_EVENT_RELEASED  
    ‚îÇ          ‚îÇ            ‚îú‚Üí Click ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îº‚Üí BUTTON_EVENT_CLICK
    ‚îÇ          ‚îÇ            ‚îú‚Üí Long Press ‚îÄ‚îÄ‚îº‚Üí BUTTON_EVENT_LONG_PRESS_*
    ‚îÇ          ‚îÇ            ‚îî‚Üí Multi-Click ‚îÄ‚îº‚Üí BUTTON_EVENT_*_CLICK
    ‚îÇ          ‚îÇ                            ‚îî‚Üí BUTTON_EVENT_SEQUENCE_*
```